## Introduction

### Problem Formulation

We are tasked with creating a code generator for a simplified C-like programming language. The code generator will take an Intermediate Representation (IR) of the program and produce assembly code for a hypothetical machine. The IR is generated by a parser that processes the source code of the language.

The code generator will be responsible for translating the IR into assembly code, ensuring that the generated code adheres to the conventions of the target machine architecture. The generated assembly code will be used to execute the program on a x86 architecture.

We will use a qemu virtual machine to run the generated assembly code. The qemu virtual machine will provide an environment for executing the assembly code, allowing us to test and validate our code generator.

### Motivation

We need the final step in the compilation process, translating the IR into assembly code. This step is crucial for executing the program on a target machine.

### Objectives

-   Implement a code generator that translates an Intermediate Representation (IR) into assembly code.
-   Ensure the generated assembly code is compatible with x86 architecture.

## Technologies

-   Python: The code generator will be implemented in Python, leveraging its capabilities for string manipulation and file handling.
-   QEMU: A virtual machine that will be used to run the generated assembly code.

## Theoretical Framework

### x86 Assembly Language

x86 assembly language is a low-level programming language that is closely related to the architecture of the x86 family of processors. It provides a set of instructions that can be used to perform operations such as arithmetic, logic, and control flow. The assembly code generated by our code generator will follow the conventions of x86 assembly language, ensuring compatibility with the target machine.

## Development

### Design Considerations

We can remember that this C based programming language is a simplified version of C, the limitations are:

-   Only supports the 'int' type
-   Functions don't accept parameters
-   No loops for are defined
-   No array or pointer support
-   Our L1 tag is the main function, so it does not appear in the IR

The grammar of the language can be found in the `parser/README.md` file, which describes the syntax of the language. The semantic analyzer will use this grammar to validate the semantic correctness of the program.

### Architecture Overview

The code generator is implemented as a single class that transforms Intermediate Representation (IR) instructions into x86 assembly code. The generator follows a systematic approach:

1. **Data Section Generation**: Creates static data definitions for string literals and helper buffers
2. **Function Analysis**: Identifies function boundaries and analyzes local variable usage
3. **IR Instruction Translation**: Maps each IR instruction type to corresponding x86 assembly sequences

### Implementation

The code generator is implemented in Python with the following essential components:

#### Core Class: `CodeGenerator`

The main class that orchestrates the IR-to-assembly translation process.

**Key Attributes:**

-   `ir_code`: List of IR instructions to process
-   `assembly_code_parts`: Dictionary organizing generated assembly into 'data' and 'text' sections
-   `var_locations`: Tracks variable memory locations within function stack frames
-   `current_function_name`: Context tracking for function-specific processing
-   `current_function_var_offsets`: Maps local variables to stack frame offsets

#### Helper Routines

The generator includes sophisticated helper routines for runtime operations, a helper routine is a function that is called by the main code generator to perform specific tasks, such as printing integers or newlines.

##### Integer-to-String Conversion (`print_integer`)

-   Converts 32-bit signed integers to ASCII representation
-   Handles negative numbers with proper sign placement
-   Uses division-based digit extraction algorithm
-   Manages a temporary buffer for string construction
-   Calls Linux `sys_write` syscall for output

##### Newline Output (`print_newline`)

-   Outputs a single newline character (0xA)
-   Uses Linux `sys_write` syscall

#### Code Generation Process

1. **IR Analysis Phase:**

    - Identify function boundaries from LabelInstr
    - Collect local variables for each function
    - Calculate stack frame requirements

2. **Assembly Generation Phase:**
    - Generate data section with buffers and string literals
    - Generate text section with function implementations
    - Translate each IR instruction to corresponding assembly
    - Add helper routines for runtime support

### Technical Specifications

#### Target Architecture

-   **Platform**: x86 (32-bit)
-   **Operating System**: Linux
-   **Assembler**: NASM (Netwide Assembler)
-   **Linker**: GNU ld (linker specification is presented bellow)
-   **Calling Convention**: Standard x86 calling convention with EBP-based stack frames

#### Supported Data Types

-   **32-bit Signed Integers**: Primary data type with full arithmetic support
-   **String Literals**: UTF-8 encoded strings with escape sequence processing
-   **Boolean Values**: For if conditions and while loops, represented as integers (0 for false, 1 for true)

### Limitations

#### Language Feature Limitations

-   **No Function Parameters**: Functions cannot accept arguments
-   **No Arrays**: No support for array data structures
-   **No Pointers**: No pointer arithmetic or dereferencing
-   **No For Loops**: for loop constructs is not supported in IR
-   **Single Data Type**: Only integer type supported
-   **No Recursion Support**: Stack overflow protection not implemented

#### Implementation Limitations

-   **No Optimization**: Generated assembly is not optimized for performance
-   **No Error Handling**: Runtime errors (division by zero, overflow) not handled
-   **Platform Specific**: Linux x86 only, not portable to other architectures
-   **Fixed Buffer Sizes**: Integer conversion buffer has fixed 12-byte limit
-   **No Debugging Support**: No debug symbols or debugging information generated

#### System Call Dependencies

-   **Linux Specific**: Uses Linux kernel system calls (int 0x80)
-   **No Windows Support**: Windows system calls not implemented
-   **No macOS Support**: macOS system calls not implemented

### Performance Characteristics

#### Code Generation Efficiency

-   **Linear Translation**: O(n) complexity where n is number of IR instructions
-   **Memory Usage**: Minimal memory overhead during generation
-   **Output Size**: Generated assembly is relatively compact but unoptimized

#### Runtime Performance

-   **Function Calls**: Standard x86 calling convention overhead
-   **Integer Operations**: Direct CPU instruction mapping for good performance
-   **String Output**: System call overhead for each print operation
-   **Memory Access**: Stack-based variable access with single-level indirection

### Integration Notes

#### Input Requirements

-   **IR Format**: List of intermediator IR instruction objects
-   **Function Structure**: Functions must start with LabelInstr
-   **Variable Names**: Must be valid assembly identifiers

#### Output Format

-   **NASM Syntax**: Generated code uses NASM assembler syntax
-   **Section Organization**: Proper .data and .text section separation
-   **Entry Point**: \_start label for program entry (main function)

#### Build Process

1. Generate assembly using CodeGenerator
2. Assemble with: `nasm -f elf32 program.asm -o program.o`
3. Link with: `ld -m elf_i386 program.o -o program`
4. Execute: `./program`

## References

-   S. GeeksforGeeks, "Issues in the design of a code generator" [Online]. Available: https://www.geeksforgeeks.org/issues-in-the-design-of-a-code-generator/. [Accessed: 01-Jun-2025].
